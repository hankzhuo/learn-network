## TCP 特点
- 在 IP 协议之上，解决网络通讯可依赖问题
  - 点对点（不能广播、多播），面向连接
  - 双向传递（全双工，比如 WebSocket）
  - 字节流：打包成报文段、保证有序接收、重复报文自动丢弃
    - 缺点：不维护应用报文的边界（对比 HTTP、GRPC），需要手动设置 Content-length
    - 优点：不强制要求应用必须离散的创建数据块，不限制数据块大小
  - 流量缓冲：解决速度不匹配问题
  - 可靠的传输服务（保证可达，丢包时通过重发进而增加时延实现可靠性
  - 拥塞控制

## 三次握手

握手目标：
- 同步 Sequence 序列号
  - 初始化序列号 ISN（Initial Sequence Number），动态生成的
- 交换 TCP 通讯参数
  - 如 MSS、窗口比例因子、选择性确认、指定校验和算法

握手流程：
1. 一开始，客户端和服务端都是 CLOSED 状态
2. 服务端主动监听某个端口，处理 LISTEN 状态
3. 客户端主动发起一个 SYN 状态的报文，客户端初始化序列号 ISN 比如是 seq=x，之后处于 SYN-SENT 状态
4. 服务端收到客户端的 SYN 报文，也会初始化序列号 ISN seq=y，同时会把把客户端序列号改为 ack=x+1，服务端返回 SYN + ACK 报文给客户端，之后处于 SYN-RCVD 状态
5. 客服端收到 SYN 和 ACK 报文之后，确认 ACK 后，把服务端接受来的序号改为 ack=y+1，发送 ACK 报文给服务端，之后处于 ESTABLISHED 状态
6. 服务端收到 ACK 后，状态也变为 ESTABLISHED
7. 客户端和服务端成功握手，这过程需要两个 RTT 时间


TCP 流
- MSS：防止 IP 层分段
- 流控：接收端的能力

MSS：Max Segement Size
- 定义：仅指 TCP 承载的数据，不包含 TCP 头部的大小
- MSS 选择目的
  - 尽量每个 Segement 报文段携带更多的数据，以减少头部空间占用比率
  - 防止 Segement 被某个设备的 IP 层基于 MTU 拆分，这样效率会降低
- 默认 MSS：536 字节（默认 MTU 576 字节，20 字节 IP 头部，20 字节 TCP 头部）
- 握手阶段协商 MSS
- MSS 分类
  - 发送方最大报文段 SMSS：Sender Max Segement Size
  - 接收方最大报文段 RMSS：Receiver Max Segement Size

## 重发

- 发送端可以并发地发送消息（顺序时由字节序列号（Sequence Number）来区分），等待接收端发回确认，如果过一段时间没得到确认，客户端会重发该序列字节（发送端有个定时器，超过设定时间也会重发，这个时间不是固定的，会根据网络好坏设置长短）
- 接收端会根据自身接收情况，更改窗口大小（Window Size Value 表示接收端目前处理能力大小)。窗口大小为 0 时候，接收端就会暂停发送，发送端会定时发送窗口探测数据包，看是否有机会调整窗口大小。当接收端比较慢时候，要防止低能窗口综合征，不会空出一个窗口就告诉发送方，而是会窗口到了一定大小，在更新窗口。
- TCP 序列号可能会导致重复，可以通过 Timestamps 时间戳来区分

RTO（Retransmission Timeout 重传时间）：
- RTO 应当略大于 RTT（Round Trip Time)
- RTO 应当更平滑


## 发送窗口和接收端口



## 拥塞控制



## TCP 四次挥手

1. 刚开始服务端和客户端都处于 ESTABLISHED 状态。客户端想断开连接，发送 FIN 报文（说“不玩了”），报文会指定一个序号 seq=p，之后进入 FIN_WAIT_1 状态，服务端收到消息“不玩了”后，会发送 ACK 报文（回复消息“知道了”），把客户端序号值作 + 1 作为 ack 报文序号值  ack = p + 1，给客户端，服务端之后进入 CLOSE_WAIT 状态
2. 客户端收到服务端消息“知道了”后，进入 FIN_WAIT_2 状态。这时候如果 B 直接断开，A 会一直保持这个状态
3. 如果服务端没有断开，发送一个 SYN、ACK 报文（消息“也不玩了”）且指定一个序号 seq=q, ack=p+1给客户端，客户端收到消息“也不玩了”后，状态从 FIN_WAIT_2 结束。
4. 客户端会回复一个 ACK 报文，并指定一个序号 ack = q + 1给服务端，客服端会处于等待一段时间 TIME_WAIT 状态，服务端收到后，双方把状态改成 CLOSE。

![](leanote://file/getImage?fileId=5d63f1f089d01b3e50000002)

为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子再关闭，这是因为要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发送 FIN 报文给客户端，客户端在收到 ACK 报文之后，就知道之前发送的 ACK 报文已经丢失了，然后再次发送 ACK 报文。

这个 TIME_WAIT 时间设为 2MSL（Maximum Segment Lifetime 报文最大生存时间），超过这个时间，报文会被丢弃，常常设为 30s ~ 2 分钟。