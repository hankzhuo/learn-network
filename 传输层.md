# UDP

UDP 特点：
1. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
2. 不需要一对一建立连接，而是可以广播应用
3. 需要处理速度快，延时低，容易少数丢包，不管网络是否阻塞，也会发送包

UDP 例子：
1. 直播协议多使用 RTMP 协议，底层还是使用 UDP 协议
2. 实时游戏
3. IoT 物联网
4. 移动流量上网的数据面对的协议 GTP-U 是基于 UDP 协议
5. QUIC 一种基于 UDP 的改进通讯协议

# TCP

## TCP 包头格式
1. 源端口号和目标端口号
2. 包序号。解决乱序问题
3. 确认包序号。发出去的包需要确认，如果没有收到，则重新发送，这可以解决不丢包问题。
4. 状态位。SYN 是发起一个链接，ACK 是响应，RST 是重新连接，FIN 是结束连接等。
5. 窗口大小。TCP 会做流量控制，标识目前能处理业务能力大小。
6. 拥塞控制。控制发送速度

![](leanote://file/getImage?fileId=5d63eb1b89d01b3e50000000)


## TCP 三次握手

例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。

所以，每个连接都要有不同的序号。这个序号会随着时间变化的，比如自增。

1. 一开始，客户端和服务端都是 CLOSED 状态
2. 服务端主动监听某个端口，处理 LISTEN 状态
3. 客户端主动发起一个 SYN 状态的报文，客户端初始化序列号 ISN(c)比如是 seq=x，之后处于 SYN-SENT 状态
4. 服务端收到客户端的 SYN 报文，也会初始化序列号ISN(s) seq=y，同时会把把客户端序列号改为 ack=x+1，服务端返回 SYN、ACK 报文给客户端，之后处于 SYN-RCVD 状态
5. 客服端收到 SYN 和 ACK 报文之后，把服务端接受来的序号改为 seq=x+1,ack=y+1，发送 ACK 报文给服务端，之后处于 ESTABLISHED 状态
6. 服务端收到 ACK 后，状态也变为 ESTABLISHED
7. 客户端和服务端成功建立连接

![](leanote://file/getImage?fileId=5d63eeed89d01b3e50000001)

**为什么需要三次握手？**

- 确认客户端和服务端双方都有接收和发送的能力。
- 为了沟通 TCP 包的序号问题

**ISN(Initial Sequence Number) 是固定的么？**

如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

**什么是半连接队列？**

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没完全建立连接，服务器会把这种状态下请求连接放在一个队列里，这就是**半连接队列**。当然还有全连接队列，就是已经完成三次握手，建立起连接都会放到全连接队列中。如果队列满了，就有可能会出现丢包的现象。

## TCP 四次挥手

1. 刚开始服务端和客户端都处于 ESTABLISHED 状态。客户端想断开连接，发送 FIN 报文（说“不玩了”），报文会指定一个序号 seq=p，之后进入 FIN_WAIT_1 状态，服务端收到消息“不玩了”后，会发送 ACK 报文（回复消息“知道了”），把客户端序号值作 + 1 作为 ack 报文序号值  ack = p + 1，给客户端，服务端之后进入 CLOSE_WAIT 状态
2. 客户端收到服务端消息“知道了”后，进入 FIN_WAIT_2 状态。这时候如果 B 直接断开，A 会一直保持这个状态
3. 如果服务端没有断开，发送一个 SYN、ACK 报文（消息“也不玩了”）且指定一个序号 seq=q, ack=p+1给客户端，客户端收到消息“也不玩了”后，状态从 FIN_WAIT_2 结束。
4. 客户端会回复一个 ACK 报文，并指定一个序号 ack = q + 1给服务端，客服端会处于等待一段时间 TIME_WAIT 状态，服务端收到后，双方把状态改成 CLOSE。

![](leanote://file/getImage?fileId=5d63f1f089d01b3e50000002)

为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子再关闭，这是因为要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发送 FIN 报文给客户端，客户端在收到 ACK 报文之后，就知道之前发送的 ACK 报文已经丢失了，然后再次发送 ACK 报文。

这个 TIME_WAIT 时间设为 2MSL（Maximum Segment Lifetime 报文最大生存时间），超过这个时间，报文会被丢弃，常常设为 30s ~ 2 分钟。


## 包的结构

为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为**累计确认**或**累计应答**。

为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。

发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分。
1. 发送了并且已经确认的
2. 发送了但还未确认的
3. 等待发送的
4. 暂时不会发送的

到底一个接收端能够同时处理多少事情呢？在 TCP 里，接收端会给发送端报一个窗口的大小，叫**Advertised window**。这个窗口的大小应该等于上面的第二部分加上第三部分。超过这个窗口的，接收端做不过来，就不能发送了。

发送端记录的数据结构

![](https://user-gold-cdn.xitu.io/2019/8/27/16cd21f87d20def0?w=716&h=210&f=jpeg&s=37103)

1. LastByteAcked：第一部分和第二部分的交界线
2. LastByteSent：第二部分和第三部分交界线
3. LastByteAcked + Advertised window：第三部分和第四部分交界线


接收端记录的内容，分为三部分
1. 接收并确认的
2. 等待接收的
3. 没法接收的

接收端记录的数据结构

![](https://user-gold-cdn.xitu.io/2019/8/27/16cd21f87d07eb02?w=734&h=239&f=jpeg&s=39166)

1. LastByteRead：之后已经接收了，但还没被应用层读取的，已经发送 ACK 给发送者了
2. NextByteExpected：第一部分和第二部分的分界线
3. MaxRcvBuffer：最大缓存的量

NextByteExpected 和 LastByteRead 的差其实是还没被应用层读取的部分占用掉的 MaxRcvBuffer 的量，我们定义为 A。

AdvertisedWindow 其实是 MaxRcvBuffer 减去 A。

Advertised window = MaxRcvBuffer - (NextByteExpected - 1 - LastByteRead)

## 顺序问题和丢包问题

**超时重试**，发送端对每个包都发送了，但没有 ACK 的包，都设有一个定时器，超过了这个时间，则重新发送，这个时间是不固定的，一直计算方法称为**自适应重传算法**。

每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

## 流量控制问题

流量控制机制，对于包的确认中，同时会携带一个窗口的大小。

接收端会根据自身接收情况，更改窗口大小。窗口大小为 0 时候，发送端就会暂停发送，发送端会定时发送窗口探测数据包，看是否有机会调整窗口大小。当接收端比较慢时候，要防止低能窗口综合征，不会空出一个窗口就告诉发送方，而是会窗口到了一定大小，在更新窗口。

## 拥塞控制问题

TCP 的拥塞控制就是在不堵塞、不丢包情况下，尽量控制带宽。网络带宽，是每秒钟能够发送多少数据。

TCP BBR  拥塞算法。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。
